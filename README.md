# Outline
實作影像編解碼流程：涵蓋色度轉換、DCT、量化、DPCM、Zigzag、RLE 等完整流程，應用於黑白與彩色影像。

# Block Flow Diagram
![流程圖](https://github.com/liuchean/encoder-and-decoder-/blob/main/images/%E6%B5%81%E7%A8%8B%E5%9C%96.png)

# 各流程說明
## 1.色度轉換(Color transform: RGB → YCbCr):將影像從 RGB 色彩空間轉換為 YCbCr，以分離亮度與色度資訊，便於壓縮與處理。
### RGB → YCbCr 色度轉換公式
```text
Y  =  0.299 R + 0.587 G + 0.114 B
Cb = -0.168736 R - 0.331264 G + 0.5 B + 128
Cr =  0.5 R - 0.418688 G - 0.081312 B + 128

R = Y+1.402(Cr-128)
G = Y-0.34414(Cb-128)-0.71414(Cr-128)
B = Y+1.772(Cb-128)
```
Y：亮度（Luminance）
Cb / Cr：色度（Chrominance），分別表示藍色與紅色的偏移量
Cb/Cr 的值透過加上 128 平移至 [0, 255] 範圍，方便儲存與後續整數運算

## 2.DCT前處理(將像素移至-128到127之間)
將像素值減去 128 將值從 [0, 255] 平移至中心為零的範圍 [-128, 127]，即可執行 DCT，而在執行完IDCT後需要+128回復其值

## 3.DCT(Discrete Cosine Transform)
將像素資訊轉換到頻域中，由於視覺獲取重要資訊的頻域都集中在低頻，所以就可以將高頻細節抹除，以達到縮小圖片檔案大小，並且不損失太多細節的目的
普遍的做法是將一圖片分成數個8*8的小方塊進行處理。
### 2D-DCT公式(8*8):
<img width="766" height="108" alt="image" src="https://github.com/user-attachments/assets/5a51bcda-311b-47bb-875b-dc7db3b72557" />

其中au、av為常數值，a0=1/sqrt(8)、ak>0=1/2
根據下方程式碼即可由內到外對應到上方式子中
```c
basic[u][v][r][c] = cos(u*M_PI*(2*r+1)/16)*cos(v*M_PI*(2*c+1)/16);
```
```c
tempY=tempY+f[i*8+r][j*8+c].Y*basic[u][v][r][c];
```
```c
if(i==0){ beta[i] = 1.0/sqrt(2); }
else{ beta[i] = 1.0; }
F[i*8+u][j*8+v].Y=beta[u]*beta[v]*0.25*tempY; //0.25=(2/sqrt(8*8))
```
## 4.Quantization
在 JPEG 壓縮流程中，量化（Quantization）是將 DCT 處理後的頻率係數進一步簡化的步驟
### 量化的目的與原理
將 DCT 轉換後的係數除以對應的「量化矩陣」值，並進行四捨五入
- 高頻部分（細節、雜訊）使用較大的除數 → 數值容易變成 0
- 低頻部分（亮度、輪廓）使用較小的除數 → 精度保留較高

這樣可以有效減少儲存的資料量，達到縮小檔案的目的。
### quantize table
```c
///////////////////////////////////////////quantize table////////////////////////////////////////
	double Q_Y[8][8]={{16, 11, 10, 16, 24, 40, 51, 61},
    			      {12, 12, 14, 19, 26, 58, 60, 55},
    			      {14, 13, 16, 24, 40, 57, 69, 56},
    			      {14, 17, 22, 29, 51, 87, 80, 62},
    			      {18, 22, 37, 56, 68,109,103, 77},
    			      {24, 35, 55, 64, 81,104,113, 92},
    			      {49, 64, 78, 87,103,121,120,101},
    			      {72, 92, 95, 98,112,100,103, 99}};


	double Q_CbCr[8][8]={{17,18,24,47,99,99,99,99},
    				    {18,21,26,66,99,99,99,99},
    				    {24,26,56,99,99,99,99,99},
    				    {47,66,99,99,99,99,99,99},
    				    {99,99,99,99,99,99,99,99},
    				    {99,99,99,99,99,99,99,99},
    				    {99,99,99,99,99,99,99,99},
    				    {99,99,99,99,99,99,99,99}};
```
## 5.DPCM(Differential Pulse Code Modulation)
在影像資料中，相鄰像素的數值通常非常接近。DPCM（Differential Pulse Code Modulation）利用這個特性，透過儲存「像素間的差值」而非「絕對值」，達到壓縮效果。
###與傳統的儲存方式差別
- 傳統儲存方式：直接儲存每個像素的絕對值
- DPCM 儲存方式：只儲存每個像素與前一個像素的差值
由於差值通常接近 0，使資料的分布更集中，進而降低資料的熵（entropy），減少編碼所需的位元數，提升壓縮效率

## 6.Zig-zag
在 JPEG 壓縮中，DCT 轉換後的 8×8 區塊會產生 64 個頻率係數，為了便於後續RLE壓縮，這些係數會透過 Zig-zag 掃描展平為一條一維序列。
### 設計原則
- 順序遵循「低頻 → 高頻」的排列邏輯，重要資訊在前，較不重要資訊在後
- 從左上角開始，沿著斜向 Z 字形擴展至右下角
  
高頻區域的係數多為 0，經Zig-zag排序後會集中成「長零串」，這就有利於RLE編碼。

### zigzag table
```c
//////////////////////////////////////zigzag table/////////////////////////////
	int vec[8][8]={{ 0, 1, 5, 6,14,15,27,28},
				   { 2, 4, 7,13,16,26,29,42},
 				   { 3, 8,12,17,25,30,41,43},
 				   { 9,11,18,24,31,40,44,53},
 				   {10,19,23,32,39,45,52,54},
 				   {20,22,33,38,46,51,55,60},
 				   {21,34,37,47,50,56,59,61},
 				   {35,36,48,49,57,58,62,63}};

```
### Zigzag 轉換式
```c
//vec[][]=0~63
//0~63 64~127.....
zig[8*8*count+vec[u][v]].Y=DPCM[i*8+u][j*8+v].Y;
```
```text
Zig-zag table的對應位置
vec[0][0] = 0
vec[0][1] = 1
vec[1][0] = 2
vec[2][0] = 3
vec[1][1] = 4
vec[0][2] = 5
...
如果將count=0時，即可展開成
zig[0].Y = DPCM[0][0].Y;  // 最左上角（最低頻）
zig[1].Y = DPCM[0][1].Y;
zig[2].Y = DPCM[1][0].Y;
zig[3].Y = DPCM[2][0].Y;
zig[4].Y = DPCM[1][1].Y;
zig[5].Y = DPCM[0][2].Y;
...
zig[63].Y = DPCM[7][7].Y; // 最右下角（最高頻）
```
## RLE(Run-Length Encoding)
RLE 編碼的核心是將連續重複的資料，用次數+資料值的方式表示，以減少儲存空間

### RLE範例
```text
假設有一串資料為222211110000
經過RLE編碼會變成424140，即可從12個字元縮減成6個字元
```
由於 RLE 的特性，使其很適合用於經過DCT和Zig-zag後的影像壓縮處理，因為其高頻數值通常都為0



